## <center> Rust基础学习 </center>
### <b>1.1 变量绑定与解构</b>
#### $\qquad$<b>手动设置变量可变性的原因</b>
$\qquad\qquad$在rust中，变量默认是不可变的，如果需要一个可变的变量需要在声明变量前添加mut关键字将该变量声明为可变的。这样设置的好处是编写代码时可以同时具有灵活性以及安全性，并且可以提升运行性能，避免多余的runtime检查。
```
    let a = "hello world" # 变量a是不可变的
    let mut b = "hello world" # 变量b是可变的
```
#### $\qquad$<b>变量命名</b>
$\qquad\qquad$<a href="https://course.rs/practice/naming.html">Rust 命名规范</a><p>
$\qquad\qquad$一般来说，对于像类型级别的构造比如说类型、枚举、结构体等一般使用驼峰命名法，对于像变量、模块、宏等使用蛇形命名法，特别的当需要命名的是常量时通常使用大写的蛇形命名法。具体使用的时候一般根据所在大环境决定使用的方法。
#### $\qquad$<b>变量绑定以及rust中所有权的概念</b>
$\qquad\qquad$在别的语言中一般称为赋值操作，由于在rust中任何内存对象一般有且只有一个主人，绑定这个内存对象给一个变量相当于让该变量称为该对象的主人，之前的主人也就丧失了对此内存对象的所有权。所以在rust中，变量绑定相对于变量赋值的含义更加清晰准确。
```
    let a = "hello world"   # 首先生成"hello world"这一个内存对象，之后将这一个内存对象绑定到变量a上。
```
#### $\qquad$<b>使用下划线开头忽略未使用的变量</b>
$\qquad\qquad$通常情况下，当在rust程序中创建了一个没有在任何地方使用的变量时，rust编译器会对该行为进行警告
```
fn main() {
    let _x = 5;
    let y = 10;
}
```
$\qquad\qquad$使用cargo run 运行之后会得到以下提示
```
  --> src\main.rs:95:9
   |
95 |     let y = 10;
   |         ^ help: if this is intentional, prefix it with an underscore: `_y`
   |
   = note: `#[warn(unused_variables)]` on by default
```
$\qquad\qquad$编译器提醒我们变量y未被使用，要求我们检查该变量是否有问题并且可以通过像_x一样以下划线开头来避免这个警告。这里还有另外一种方法，因为默认情况下rust对未使用的变量执行的策略是warn，我们可以在函数上通过设置```#[allow(unused_variables)]```语句来改变对未使用变量的策略为允许，这样编译器也不会警告变量未使用了。
```
#[allow(unused_variables)]
fn main() {
    let _x = 5;
    let y = 10;
}
```
#### $\qquad$<b>变量解构</b>